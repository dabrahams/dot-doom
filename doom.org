:DOC-CONFIG:
# Tangle by default to config.el, which is the most common case
#+property: header-args:emacs-lisp :tangle config.el
#+property: header-args :mkdirp yes :comments no
#+startup: fold
:END:

#+title: Doom Emacs configuration
#+author: Dave Abrahams
#+email: dave@boostpro.com

[[file:splash/doom-emacs-bw-light.svg]]

Based on the work of Diego Zamboni <diego@zzamboni.org>

This file is written in [[https://leanpub.com/lit-config][literate programming style]] using [[https://orgmode.org/][org-mode]]. See [[file:init.el][init.el]],
[[file:packages.el][packages.el]] and [[file:config.el][config.el]] for the generated files. 

* Doom config file overview

Doom Emacs uses three config files:

- =init.el= defines which of the existing Doom [[https://github.com/hlissner/doom-emacs/blob/develop/docs/getting_started.org#modules][modules]] are loaded. A Doom module
  is a bundle of packages, configuration and commands, organized into a unit
  that can be toggled easily from this file.
- =packages.el= defines which [[https://github.com/hlissner/doom-emacs/blob/develop/docs/getting_started.org#package-management][packages]] should be installed, beyond those that
  are installed and loaded as part of the enabled modules.
- =config.el= contains all [[https://github.com/hlissner/doom-emacs/blob/develop/docs/getting_started.org#configuring-doom][custom configuration]] and code.

There are other files that can be loaded, but theses are the main ones. The load
order of different files is [[https://github.com/hlissner/doom-emacs/blob/develop/docs/getting_started.org#load-order][defined depending on the type of session]] being
started.

All the config files are generated from this Org file, to try and make its
meaning as clear as possible. All =package!= declarations are written to
=packages.el=, all other LISP code is written to =config.el=.

** Config file headers

We start by simply defining the standard headers used by the three files. These
headers come from the initial files generated by =doom install=, and contain
either some Emacs-LISP relevant indicators like =lexical-binding=, or
instructions about the contents of the file.

#+html: <details><summary>init.el</summary>
#+begin_src emacs-lisp :tangle init.el
;;; init.el -*- lexical-binding: t; -*-

;; DO NOT EDIT THIS FILE DIRECTLY
;; This is a file generated from a literate programing source file located at
;; https://github.com/dabrahams/dot-doom/blob/main/doom.org
;; You should make any changes there and regenerate it from Emacs org-mode
;; using org-babel-tangle (C-c C-v t)

;; This file controls what Doom modules are enabled and what order they load
;; in. Remember to run 'doom sync' after modifying it!

;; NOTE Press 'SPC h d h' (or 'C-h d h' for non-vim users) to access Doom's
;;      documentation. There you'll find a "Module Index" link where you'll find
;;      a comprehensive list of Doom's modules and what flags they support.

;; NOTE Move your cursor over a module's name (or its flags) and press 'K' (or
;;      'C-c c k' for non-vim users) to view its documentation. This works on
;;      flags as well (those symbols that start with a plus).
;;
;;      Alternatively, press 'gd' (or 'C-c c d') on a module to browse its
;;      directory (for easy access to its source code).
#+end_src
#+html: </details>

#+html: <details><summary>packages.el</summary>
#+begin_src emacs-lisp :tangle packages.el
;; -*- no-byte-compile: t; -*-
;;; $DOOMDIR/packages.el

;; DO NOT EDIT THIS FILE DIRECTLY
;; This is a file generated from a literate programing source file located at
;; https://github.com/dabrahams/dot-doom/blob/main/doom.org
;; You should make any changes there and regenerate it from Emacs org-mode
;; using org-babel-tangle (C-c C-v t)

;; To install a package with Doom you must declare them here and run 'doom sync'
;; on the command line, then restart Emacs for the changes to take effect -- or
;; use 'M-x doom/reload'.

;; To install SOME-PACKAGE from MELPA, ELPA or emacsmirror:
;;(package! some-package)

;; To install a package directly from a remote git repo, you must specify a
;; `:recipe'. You'll find documentation on what `:recipe' accepts here:
;; https://github.com/raxod502/straight.el#the-recipe-format
;;(package! another-package
;;  :recipe (:host github :repo "username/repo"))

;; If the package you are trying to install does not contain a PACKAGENAME.el
;; file, or is located in a subdirectory of the repo, you'll need to specify
;; `:files' in the `:recipe':
;;(package! this-package
;;  :recipe (:host github :repo "username/repo"
;;           :files ("some-file.el" "src/lisp/*.el")))

;; If you'd like to disable a package included with Doom, you can do so here
;; with the `:disable' property:
;;(package! builtin-package :disable t)

;; You can override the recipe of a built in package without having to specify
;; all the properties for `:recipe'. These will inherit the rest of its recipe
;; from Doom or MELPA/ELPA/Emacsmirror:
;;(package! builtin-package :recipe (:nonrecursive t))
;;(package! builtin-package-2 :recipe (:repo "myfork/package"))

;; Specify a `:branch' to install a package from a particular branch or tag.
;; This is required for some packages whose default branch isn't 'master' (which
;; our package manager can't deal with; see raxod502/straight.el#279)
;;(package! builtin-package :recipe (:branch "develop"))

;; Use `:pin' to specify a particular commit to install.
;;(package! builtin-package :pin "1a2b3c4d5e")

;; Doom's packages are pinned to a specific commit and updated from release to
;; release. The `unpin!' macro allows you to unpin single packages...
;;(unpin! pinned-package)
;; ...or multiple packages
;;(unpin! pinned-package another-pinned-package)
;; ...Or *all* packages (NOT RECOMMENDED; will likely break things)
;;(unpin! t)
#+end_src
#+html: </details>

#+html: <details><summary>config.el</summary>
#+begin_src emacs-lisp :tangle config.el
;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-

;; DO NOT EDIT THIS FILE DIRECTLY
;; This is a file generated from a literate programing source file located at
;; https://github.com/dabrahams/dot-doom/blob/main/doom.org
;; You should make any changes there and regenerate it from Emacs org-mode
;; using org-babel-tangle (C-c C-v t)

;; Place your private configuration here! Remember, you do not need to run 'doom
;; sync' after modifying this file!

;; Some functionality uses this to identify you, e.g. GPG configuration, email
;; clients, file templates and snippets.
;; (setq user-full-name "John Doe"
;;      user-mail-address "john@doe.com")

;; Doom exposes five (optional) variables for controlling fonts in Doom. Here
;; are the three important ones:
;;
;; + `doom-font'
;; + `doom-variable-pitch-font'
;; + `doom-big-font' -- used for `doom-big-font-mode'; use this for
;;   presentations or streaming.
;;
;; They all accept either a font-spec, font string ("Input Mono-12"), or xlfd
;; font string. You generally only need these two:
;; (setq doom-font (font-spec :family "monospace" :size 12 :weight 'semi-light)
;;       doom-variable-pitch-font (font-spec :family "sans" :size 13))

;; There are two ways to load a theme. Both assume the theme is installed and
;; available. You can either set `doom-theme' or manually load a theme with the
;; `load-theme' function. This is the default:
;; (setq doom-theme 'doom-one)

;; If you use `org' and don't want your org files in the default location below,
;; change `org-directory'. It must be set before org loads!
;; (setq org-directory "~/org/")

;; This determines the style of line numbers in effect. If set to `nil', line
;; numbers are disabled. For relative line numbers, set this to `relative'.
;; (setq display-line-numbers-type t)

;; Here are some additional functions/macros that could help you configure Doom:
;;
;; - `load!' for loading external *.el files relative to this one
;; - `use-package!' for configuring packages
;; - `after!' for running code after a package has loaded
;; - `add-load-path!' for adding directories to the `load-path', relative to
;;   this file. Emacs searches the `load-path' when you load packages with
;;   `require' or `use-package'.
;; - `map!' for binding new keys
;;
;; To get information about any of these functions/macros, move the cursor over
;; the highlighted symbol at press 'K' (non-evil users must press 'C-c c k').
;; This will open documentation for it, including demos of how they are used.
;;
;; You can also try 'gd' (or 'C-c c d') to jump to their definition and see how
;; they are implemented.
#+end_src
#+html: </details>


* Doom modules

This code is written to the =init.el= to select which modules to load. Written
here as-is for now, as it is quite well structured and clear.

#+begin_src emacs-lisp :tangle init.el
(doom!
 :input
 ;;;chinese
 ;;;japanese
 ;;;layout              ; auie,ctsrnm is the superior home row

 :completion
 (company +childframe) ; the ultimate code completion backend
 ;;;helm                ; the *other* search engine for love and life
 ;;ido                 ; the other *other* search engine...
 (ivy +prescient -childframe
      -fuzzy +icons)   ; a search engine for love and life

 :ui
 ;deft                ; notational velocity for Emacs
 doom                  ; what makes DOOM look the way it does
 doom-dashboard        ; a nifty splash screen for Emacs
 ;;;doom-quit           ; DOOM quit-message prompts when you quit Emacs
 fill-column         ; a `fill-column' indicator
 ;hl-todo               ; highlight TODO/FIXME/NOTE/DEPRECATED/HACK/REVIEW
 ;;hydra
 ;;indent-guides       ; highlighted indent columns
 (ligatures +extra)    ; ligatures or substitute text with pretty symbols
 ;;minimap             ; show a map of the code on the side
 modeline              ; snazzy, Atom-inspired modeline, plus API
 ;nav-flash             ; blink cursor line after big motions
 ;;neotree             ; a project drawer, like NERDTree for vim
 ;ophints               ; highlight the region an operation acts on
 ;;(popup +defaults)   ; tame sudden yet inevitable temporary windows
 ;;tabs                ; a tab bar for Emacs
 ;treemacs            ; a project drawer, like neotree but cooler
 ;unicode             ; extended unicode support for various languages
 ;vc-gutter           ; vcs diff in the fringe
 ;;vi-tilde-fringe       ; fringe tildes to mark beyond EOB
 ;window-select         ; visually switch windows
 workspaces            ; tab emulation, persistence & separate workspaces
 zen                   ; distraction-free coding or writing

 :editor
 ;;;(evil +everywhere)  ; come to the dark side, we have cookies
 ;file-templates        ; auto-snippets for empty files
 ;fold                ; (nigh) universal code folding
 ;(format +onsave)    ; automated prettiness
 ;;god                 ; run Emacs commands without modifier keys
 ;;lispy               ; vim for lisp, for people who don't like vim
 ;multiple-cursors    ; editing in many places at once
 ;;objed               ; text object editing for the innocent
 ;;parinfer            ; turn lisp into python, sort of
 ;rotate-text         ; cycle region at point between text candidates
 ;snippets              ; my elves. They type so I don't have to
 ;;word-wrap           ; soft wrapping with language-aware indent

 :emacs
 dired                 ; making dired pretty [functional]
 ;electric              ; smarter, keyword-based electric-indent
 ;ibuffer             ; interactive buffer management
 ;undo                  ; persistent, smarter undo for your inevitable mistakes
 ;vc                    ; version-control and Emacs, sitting in a tree

 :term
 ;;eshell              ; the elisp shell that works everywhere
 ;shell               ; simple shell REPL for Emacs
 ;;term                ; basic terminal emulator for Emacs
 ;vterm                ; the best terminal emulation in Emacs

 :checkers
 ;(syntax +childframe)  ; tasing you for every semicolon you forget
 ;spell                 ; tasing you for misspelling mispelling
 ;;grammar             ; tasing grammar mistake every you make

 :tools
 ;;ansible
 ;debugger              ; FIXME stepping through code, to help you add bugs
 ;;direnv
 ;;docker
 ;;editorconfig        ; let someone else argue about tabs vs spaces
 ;;ein                 ; tame Jupyter notebooks with emacs
 ;(eval +overlay)       ; run code, run (also, repls)
 ;gist                  ; interacting with github gists
 ;lookup                ; navigate your code and its documentation
 ;lsp
 (magit)        ; a git porcelain for Emacs
 ;;make                ; run make tasks from Emacs
 ;;pass                  ; password manager for nerds
 ;pdf                 ; pdf enhancements
 ;;prodigy             ; FIXME managing external services & code builders
 ;;rgb                 ; creating color strings
 ;;taskrunner          ; taskrunner for all your projects
 ;;terraform           ; infrastructure as code
 ;tmux                ; an API for interacting with tmux
 ;upload              ; map local to remote projects via ssh/ftp

 :os
 (:if IS-MAC macos)    ; improve compatibility with macOS
 ;tty                 ; improve the terminal Emacs experience

 :lang
 ;;agda                ; types of types of types of types...
 cc                  ; C/C++/Obj-C madness
 ;;clojure             ; java with a lisp
 ;;;common-lisp           ; if you've seen one lisp, you've seen them all
 ;;;coq                 ; proofs-as-programs
 ;crystal             ; ruby at the speed of c
 ;;csharp              ; unity, .NET, and mono shenanigans
 ;data                ; config/data formats
 ;(dart +flutter)     ; paint ui and not much else
 ;;elixir              ; erlang done right
 ;;elm                 ; care for a cup of TEA?
 emacs-lisp            ; drown in parentheses
 ;;;erlang              ; an elegant language for a more civilized age
 ;;;(ess +lsp)            ; emacs speaks statistics
 ;;;faust               ; dsp, but you get to keep your soul
 ;;;fsharp              ; ML stands for Microsoft's Language
 ;;;fstar               ; (dependent) types and (monadic) effects and Z3
 ;;;gdscript            ; the language you waited for
 ;;(go +lsp)             ; the hipster dialect
 ;;(haskell +dante)    ; a language that's lazier than I am
 ;;;hy                  ; readability of scheme w/ speed of python
 ;;;idris               ; a language you can depend on
 json                  ; At least it ain't XML
 ;;(java +meghanada)   ; the poster child for carpal tunnel syndrome
 ;javascript          ; all(hope(abandon(ye(who(enter(here))))))
 ;;julia               ; a better, faster MATLAB
 ;;kotlin              ; a better, slicker Java(Script)
 (latex +latexmk)      ; writing papers in Emacs has never been so fun
 ;;lean
 ;;factor
 ;;ledger              ; an accounting system in Emacs
 ;lua                   ; one-based indices? one-based indices
 markdown              ; writing docs for people to ignore
 ;;nim                 ; python + lisp at the speed of c
 ;;nix                 ; I hereby declare "nix geht mehr!"
 ;;ocaml               ; an objective camel
 (org +pretty +journal -dragndrop
      +hugo +roam +pandoc
      +present)        ; organize your plain life in plain text
 ;;php                 ; perl's insecure younger brother
 ;;plantuml              ; diagrams for confusing people more
 ;;purescript          ; javascript, but functional
 python                ; beautiful is better than ugly
 ;;qt                  ; the 'cutest' gui framework ever
 ;;racket                ; a DSL for DSLs
 ;;raku                ; the artist formerly known as perl6
 ;;rest                ; Emacs as a REST client
 rst                   ; ReST in peace
 ;;(ruby +rails)       ; 1.step {|i| p "Ruby is #{i.even? ? 'love' : 'life'}"}
 rust                ; Fe2O3.unwrap().unwrap().unwrap().unwrap()
 ;;scala               ; java, but good
 ;;scheme              ; a fully conniving family of lisps
 (sh +lsp)             ; she sells {ba,z,fi}sh shells on the C xor
 ;;sml
 ;;solidity            ; do you need a blockchain? No.
 swift               ; who asked for emoji variables?
 ;;terra               ; Earth and Moon in alignment for performance.
 ;web                 ; the tubes
 (yaml +lsp)           ; JSON, but readable

 :email
 ;(mu4e +gmail)
 ;notmuch
 ;(wanderlust +gmail)

 :app
 ;;calendar
 irc                   ; how neckbeards socialize
 ;;(rss +org)          ; emacs as an RSS reader
 ;twitter             ; twitter client https://twitter.com/vnought

 :config
 ;literate
 ;(default +bindings +smartparens)
)
#+end_src

* General configuration

My user information.

#+begin_src emacs-lisp
(setq user-full-name "Dave Abrahams"
  user-mail-address "dabrahams@google.com")
#+end_src

Change the Mac modifiers to my liking

#+begin_src emacs-lisp
(cond (IS-MAC
       (setq mac-command-modifier      'meta
             mac-option-modifier       'alt
             mac-right-option-modifier 'alt)))
#+end_src

Disable line numbers.

#+begin_src emacs-lisp
;; This determines the style of line numbers in effect. If set to `nil', line
;; numbers are disabled. For relative line numbers, set this to `relative'.
(setq display-line-numbers-type nil)
#+end_src

For some reason Doom disables auto-save and backup files by default. Let's reenable them.

#+begin_src emacs-lisp
(setq auto-save-default t
      make-backup-files t)
#+end_src

Disable exit confirmation.

#+begin_src emacs-lisp
(setq confirm-kill-emacs nil)
#+end_src

** Visual, session and window settings

If you want to choose at random among a few different splash images, you can
list them in =alternatives=.

#+begin_src emacs-lisp
(let ((alternatives '("doom-emacs-color2.svg")))
   ;;((alternatives '("doom-emacs-color.png" "doom-emacs-bw-light.svg")))
  (setq fancy-splash-image
        (concat doom-private-dir "splash/"
                (nth (random (length alternatives)) alternatives))))
#+end_src

Set base and variable-pitch fonts.

#+begin_src emacs-lisp
(setq doom-font (font-spec :family "Monaco" :size 15)
      ;;doom-variable-pitch-font (font-spec :family "ETBembo" :size 18)
      doom-variable-pitch-font (font-spec :family "Euphemia UCAS" :size 15))
#+end_src

Mixed-pitch support. Particularly useful for Org mode, where documents typically
contain both prose and source code.

#+begin_src emacs-lisp
(defun dwa/no-mixed-pitch-fill-column-indicator ()
  (when mixed-pitch-mode (display-fill-column-indicator-mode 0)))

(after! mixed-pitch
  (setq mixed-pitch-variable-pitch-cursor nil)
  (add-hook! 'mixed-pitch-mode-hook
             #'dwa/no-mixed-pitch-fill-column-indicator))

(after! org
  (add-hook! 'org-mode-hook #'mixed-pitch-mode))
#+end_src

Visual theme

#+begin_src emacs-lisp
(setq doom-theme 'doom-tomorrow-day)
(setq doom-theme 'doom-one)
;;(setq doom-theme 'doom-nord-light)
;;(setq doom-theme 'doom-solarized-light)
#+end_src

In my previous configuration, I used to automatically restore the previous
session upon startup. Doom Emacs starts up so fast that it does not feel right
to do it automatically. In any case, from the Doom dashboard I can simply press
Enter to invoke the first item, which is "Reload Last Session". So this code is
commented out now.

#+begin_src emacs-lisp
;;(add-hook 'window-setup-hook #'doom/quickload-session)
#+end_src

Maximize the window upon startup, and no toolbars!.

#+begin_src emacs-lisp
(add-to-list 'initial-frame-alist '(fullscreen . maximized))
(modify-frame-parameters
  nil (list (cons 'tool-bar-lines 0)))
#+end_src

Truncate lines in =ivy= childframes. [[https://discord.com/channels/406534637242810369/484105925733646336/770756709857755187][Thanks Henrik]]! (disabled for now)

#+begin_src emacs-lisp :tangle no
(setq posframe-arghandler
      (lambda (buffer-or-name key value)
        (or (and (eq key :lines-truncate)
                 (equal ivy-posframe-buffer
                        (if (stringp buffer-or-name)
                            buffer-or-name
                          (buffer-name buffer-or-name)))
                 t)
            value)))
#+end_src
** Key bindings
This section includes supporting code for relatively trivial functions that
support ergonomic keybindings, but more substantial mode customizations or
functionality beyond ~(interactive)~ commands will be found elsewhere.

*** Disable some built-in annoyances.
C-z is okay when we're running in a terminal, but minimizing the graphical frame I'm running in is just a pain.
#+begin_src emacs-lisp
(when window-system (map! "C-z" nil))
#+end_src

#+begin_src emacs-lisp
(map! "C-\\" nil) ;; toggle-input-method
#+end_src

*** Dave's essential global bindings

**** Basics
#+begin_src emacs-lisp
(map! :map override
      "<C-return>"  #'other-window
      "C-," #'backward-word
      "C-." #'forward-word
      ;; Defaults go to the beginning/end of line
      [home] #'beginning-of-buffer
      [end] #'end-of-buffer)
#+end_src

If we don't do this up front, it won't get bound until dired has been loaded.

#+begin_src emacs-lisp
(map! "C-x C-j" #'dired-jump)
#+end_src

**** Parenthesis matching:
#+begin_src emacs-lisp
(defun dwa/match-paren (arg)
  (interactive "P")
  (if arg
      () ;;(insert "%")  ; insert the character we're bound to
    (cond ((looking-at "[[({<]")
           (forward-sexp 1)
           (forward-char -1))
          ((looking-at "[]})>]")
           (forward-char 1)
           (forward-sexp -1))
          (t
           ;; (insert "%")  ; insert the character we're bound to
      ))))

(map! :map override "C-(" #'dwa/match-paren)
#+end_src

**** Buffers

~C-x C-b~ is normally set to bring up a buffer list, but there are many other ways
to invoke this seldom-desired command (e.g. C-mouse1, or look at the "Buffers"
menu at the top of the frame).

#+begin_src emacs-lisp
(defun dwa/other-buffer ()
  "Switch to the most recently visited buffer without asking"
  (interactive)
  (switch-to-buffer nil))

(map! :map override "C-x C-b" #'dwa/other-buffer)
#+end_src

~C-x C-k~ is normally brings up a list of buffers to kill. I just want to kill
this one, now!

#+BEGIN_SRC emacs-lisp
(defun dwa/kill-current-buffer ()
  "Kill the current buffer without asking, unless it's modified file, in which case ask first"
  (interactive)
  (kill-buffer (current-buffer)))

(map! :map override "C-x C-k" 'dwa/kill-current-buffer)
#+END_SRC

**** Help
#+BEGIN_SRC emacs-lisp
(map! :map override
      "C-h M" 'man
      :prefix "C-h e"
      "a" #'dwa/anything-apropos
      "e" #'view-echo-area-messages
      "f" #'find-function
      "d" #'my-describe-symbol
      "i" #'info-apropos
      "k" #'find-function-on-key
      "l" #'find-library
      "o" #'customize-option
      "g" #'customize-group
      "s" #'scratch
      "v" #'find-variable)
#+END_SRC

**** Compilation
Attempt to do easy compilation with scrolling errors, and easy
recompilation without worrying about what buffer you're in.

TODO: Someone must have done this better than me; look into it.

#+begin_src emacs-lisp
;; Used by dwa/compile and dwa/recompile to get back to the bottom of a
;; compilation buffer after save-excursion brings us back to the place we
;; started.
(defun dwa/end-of-current-compilation-buffer()
  (if (equal (buffer-name) "*compilation*")
      (goto-char (point-max))))

(defun dwa/compile(&optional command)
  (interactive)
  (if (interactive-p)
      (call-interactively 'compile)
    (compile command))
  (save-excursion
    (pop-to-buffer "*compilation*")
    (goto-char (point-max)))
  ;; force scrolling despite save-excursion
  (dwa/end-of-current-compilation-buffer))

(defun dwa/buffer-exists (buffer)
  "Return t if the buffer exists.
buffer is either a buffer object or a buffer name"
  (bufferp (get-buffer buffer)))

(defun dwa/recompile ()
  "Run recompilation but put the point at the *end* of the buffer
so we can watch errors as they come up"
  (interactive)
  (if (and (dwa/buffer-exists "*compilation*")
           compile-command)
      (save-excursion
        ;; switching to the compilation buffer here causes the compile command to be
        ;; executed from the same directory it originated from.
        (pop-to-buffer "*compilation*")
        (recompile)
        (pop-to-buffer "*compilation*")
        (goto-char (point-max)))
    ;; else
    (call-interactively #'dwa/compile))
  ;; force scrolling despite save-excursion
  (dwa/end-of-current-compilation-buffer))

(map! :map override
      [f7] #'dwa/recompile
      [C-f7] #'dwa/compile
      [f4] #'next-error
      [C-S-f4] #'next-error
      [S-f4] #'previous-error
      [C-f4] #'first-error)
#+end_src


*** Mode-specific bindings
**** ~dired~
#+begin_src emacs-lisp
(defun dwa/dired-copy-full-path-as-kill ()
  "Copies the full path of the marked files into the kill buffer."
  (interactive)
  (setq current-prefix-arg '(0))
  (call-interactively 'dired-copy-filename-as-kill))
(map! :map dired-mode-map "W" #'dwa/dired-copy-full-path-as-kill)
#+end_src


*** Miscellaneous keybindings

The Doom =undo= package introduces the use of [[https://gitlab.com/ideasman42/emacs-undo-fu][=undo-fu=]], which makes undo/redo
more "lineal". I normally use ~C-/~ for undo and Emacs doesn't have a separate
"redo" action, so I map ~C-?~ (in my keyboard, the same combination + ~Shift~)
for redo.

#+begin_src emacs-lisp
(after! undo-fu
  (map! :map undo-fu-mode-map "C-?" #'undo-fu-only-redo))
#+end_src

** Other crucial ergonomic settings

Be like every other editor: when text is selected and I start typing, the
selected text should be replaced.
#+begin_src emacs-lisp
(delete-selection-mode t)
#+end_src

* Org mode

This came almost entirely from Diego Zamboni.

** General Org Configuration

Default directory for Org files.

#+begin_src emacs-lisp
(setq org-directory "~/GSync/org/")
#+end_src

Hide Org markup indicators.

#+begin_src emacs-lisp
(after! org (setq org-hide-emphasis-markers t))
#+end_src

Insert Org headings where I say

#+begin_src emacs-lisp
(after! org (setq org-insert-heading-respect-content nil))
#+end_src

Enable logging of done tasks, and log stuff into the LOGBOOK drawer by default

#+begin_src emacs-lisp
(after! org
  (setq org-log-done t)
  (setq org-log-into-drawer t))
#+end_src

Use the special ~C-a~, ~C-e~ and ~C-k~ definitions for Org, which enable some special behavior in headings.

#+begin_src emacs-lisp
(after! org
  (setq org-special-ctrl-a/e t)
  (setq org-special-ctrl-k t))
#+end_src

I really dislike completion of words as I type prose (in code it's OK), so I disable it in Org:

#+begin_src emacs-lisp
(defun zz/adjust-org-company-backends ()
  (remove-hook 'after-change-major-mode-hook '+company-init-backends-h)
  (setq-local company-backends nil))
(add-hook! org-mode (zz/adjust-org-company-backends))
#+end_src
** Org visual settings

Enable variable pitch mode in Org mode by default.

#+begin_src emacs-lisp
(add-hook! org-mode :append
           #'variable-pitch-mode)
#+end_src

Use [[https://github.com/awth13/org-appear][org-appear]] to reveal emphasis markers when moving the cursor over them.

#+begin_src emacs-lisp :tangle packages.el
(package! org-appear
  :recipe (:host github
           :repo "awth13/org-appear"))
#+end_src
#+begin_src emacs-lisp
(add-hook! org-mode :append #'org-appear-mode)
#+end_src
** Capturing and note taking

First, I define where all my Org-captured things can be found.

#+begin_src emacs-lisp
(after! org
  (setq org-agenda-files
        '("~/GSync/gtd" "~/GSync/Work/work.org.gpg" org-directory)))
#+end_src

I define some global keybindings to open my frequently-used org files (original
tip from [[https://sachachua.com/blog/2015/02/learn-take-notes-efficiently-org-mode/][Learn how to take notes more efficiently in Org Mode]]).

First, I define a helper function to define keybindings that open files. Note
that this requires lexical binding to be enabled, so that the =lambda= creates a
closure, otherwise the keybindings don't work.

#+begin_src emacs-lisp
(defun zz/add-file-keybinding (key file &optional desc)
  (let ((key key)
        (file file)
        (desc desc))
    (map! :desc (or desc file)
          key
          (lambda () (interactive) (find-file file)))))
#+end_src

Now I define keybindings to access my commonly-used org files.

#+begin_src emacs-lisp
(zz/add-file-keybinding "C-c z w" "~/GSync/Work/work.org.gpg" "work.org")
(zz/add-file-keybinding "C-c z i" (concat org-directory "ideas.org") "ideas.org")
(zz/add-file-keybinding "C-c z p" (concat org-directory "projects.org") "projects.org")
(zz/add-file-keybinding "C-c z d" (concat org-directory "diary.org") "diary.org")
#+end_src

** Capturing images

Using =org-download= to make it easier to insert images into my org notes. I
don't like the configuration provided by Doom as part of the =(org +dragndrop)=
module, so I install the package by hand and configure it to my liking. I also
define a new keybinding to paste an image from the clipboard, asking for the
filename first.

#+begin_src emacs-lisp :tangle packages.el
(package! org-download)
#+end_src
#+begin_src emacs-lisp
(defun zz/org-download-paste-clipboard (&optional use-default-filename)
  (interactive "P")
  (require 'org-download)
  (let ((file
         (if (not use-default-filename)
             (read-string (format "Filename [%s]: "
                                  org-download-screenshot-basename)
                          nil nil org-download-screenshot-basename)
           nil)))
    (org-download-clipboard file)))

(after! org
  (setq org-download-method 'directory)
  (setq org-download-image-dir "images")
  (setq org-download-heading-lvl nil)
  (setq org-download-timestamp "%Y%m%d-%H%M%S_")
  (setq org-image-actual-width 300)
  (map! :map org-mode-map
        "C-c l a y" #'zz/org-download-paste-clipboard
        "C-M-y" #'zz/org-download-paste-clipboard))
#+end_src

** Capturing links

*** Capturing and creating internal Org links

I normally use =counsel-org-link= for linking between headings in an Org document. It shows me a searchable list of all the headings in the current document, and allows selecting one, automatically creating a link to it. Since it doesn't have a keybinding by default, I give it one.

#+begin_src emacs-lisp
(map! :after counsel :map org-mode-map
      "C-c l l h" #'counsel-org-link)
#+end_src

I also configure =counsel-outline-display-style= so that only the headline title is inserted into the link, instead of its full path within the document.

#+begin_src emacs-lisp
(after! counsel
  (setq counsel-outline-display-style 'title))
#+end_src

=counsel-org-link= uses =org-id= as its backend which generates IDs using UUIDs, and it uses the =ID= property to store them. I prefer using human-readable IDs stored in the =CUSTOM_ID= property of each heading, so we need to make some changes.

First, configure =org-id= to use =CUSTOM_ID= if it exists. This affects the links generated by the =org-store-link= function.

#+begin_src emacs-lisp
(after! org-id
  ;; Do not create ID if a CUSTOM_ID exists
  (setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id))
#+end_src

Second, I override =counsel-org-link-action=, which is the function that actually generates and inserts the link, with a custom function that computes and inserts human-readable =CUSTOM_ID= links. This is supported by a few auxiliary functions for generating and storing the =CUSTOM_ID=.

#+begin_src emacs-lisp
(defun zz/make-id-for-title (title)
  "Return an ID based on TITLE."
  (let* ((new-id (replace-regexp-in-string "[^[:alnum:]]" "-" (downcase title))))
    new-id))

(defun zz/org-custom-id-create ()
  "Create and store CUSTOM_ID for current heading."
  (let* ((title (or (nth 4 (org-heading-components)) ""))
         (new-id (zz/make-id-for-title title)))
    (org-entry-put nil "CUSTOM_ID" new-id)
    (org-id-add-location new-id (buffer-file-name (buffer-base-buffer)))
    new-id))

(defun zz/org-custom-id-get-create (&optional where force)
  "Get or create CUSTOM_ID for heading at WHERE.

If FORCE is t, always recreate the property."
  (org-with-point-at where
    (let ((old-id (org-entry-get nil "CUSTOM_ID")))
      ;; If CUSTOM_ID exists and FORCE is false, return it
      (if (and (not force) old-id (stringp old-id))
          old-id
        ;; otherwise, create it
        (zz/org-custom-id-create)))))

;; Now override counsel-org-link-action
(after! counsel
  (defun counsel-org-link-action (x)
    "Insert a link to X.

X is expected to be a cons of the form (title . point), as passed
by `counsel-org-link'.

If X does not have a CUSTOM_ID, create it based on the headline
title."
    (let* ((id (zz/org-custom-id-get-create (cdr x))))
      (org-insert-link nil (concat "#" id) (car x)))))
#+end_src

Ta-da! Now using =counsel-org-link= inserts nice, human-readable links.

*** Capturing links to external applications

=org-mac-link= implements the ability to grab links from different Mac apps and insert them in the file. Bind =C-c g= to call =org-mac-grab-link= to choose an application and insert a link.

#+begin_src emacs-lisp
(when IS-MAC
  (use-package! org-mac-link
    :after org
    :config
    (setq org-mac-grab-Acrobat-app-p nil) ; Disable grabbing from Adobe Acrobat
    (setq org-mac-grab-devonthink-app-p nil) ; Disable grabbinb from DevonThink
    (map! :map org-mode-map
          "C-c g"  #'org-mac-grab-link)))
#+end_src

** Tasks and agenda

Customize the agenda display to indent todo items by level to show nesting, and enable showing holidays in the Org agenda display.

#+begin_src emacs-lisp
(after! org-agenda
  (setq org-agenda-prefix-format
        '((agenda . " %i %-12:c%?-12t% s")
          ;; Indent todo items by level to show nesting
          (todo . " %i %-12:c%l")
          (tags . " %i %-12:c")
          (search . " %i %-12:c")))
  (setq org-agenda-include-diary t))
#+end_src

Install and load some custom local holiday lists I'm interested in.

#+begin_src emacs-lisp :tangle packages.el
(package! mexican-holidays)
(package! swiss-holidays)
#+end_src
#+begin_src emacs-lisp
(use-package! holidays
  :after org-agenda
  :config
  (require 'mexican-holidays)
  (require 'swiss-holidays)
  (setq swiss-holidays-zh-city-holidays
        '((holiday-float 4 1 3 "Sechseläuten")
          (holiday-float 9 1 3 "Knabenschiessen")))
  (setq calendar-holidays
        (append '((holiday-fixed 1 1 "New Year's Day")
                  (holiday-fixed 2 14 "Valentine's Day")
                  (holiday-fixed 4 1 "April Fools' Day")
                  (holiday-fixed 10 31 "Halloween")
                  (holiday-easter-etc)
                  (holiday-fixed 12 25 "Christmas")
                  (solar-equinoxes-solstices))
                swiss-holidays
                swiss-holidays-labour-day
                swiss-holidays-catholic
                swiss-holidays-zh-city-holidays
                holiday-mexican-holidays)))
#+end_src

[[https://github.com/alphapapa/org-super-agenda][org-super-agenda]] provides great grouping and customization features to make agenda mode easier to use.

#+begin_src emacs-lisp :tangle packages.el
(package! org-super-agenda)
#+end_src
#+begin_src emacs-lisp
(use-package! org-super-agenda
  :after org-agenda
  :config
  (setq org-super-agenda-groups '((:auto-dir-name t)))
  (org-super-agenda-mode))
#+end_src

I configure =org-archive= to archive completed TODOs by default to the =archive.org= file in the same directory as the source file, under the "date tree" corresponding to the task's CLOSED date - this allows me to easily separate work from non-work stuff. Note that this can be overridden for specific files by specifying the desired value of =org-archive-location= in the =#+archive:= property at the top of the file.

#+begin_src emacs-lisp
(use-package! org-archive
  :after org
  :config
  (setq org-archive-location "archive.org::datetree/"))
#+end_src

I have started using =org-clock= to track time I spend on tasks. Often I restart Emacs for different reasons in the middle of a session, so I want to persist all the running clocks and their history.

#+begin_src emacs-lisp
(after! org-clock
  (setq org-clock-persist t)
  (org-clock-persistence-insinuate))
#+end_src

** GTD

I am trying out Trevoke's [[https://github.com/Trevoke/org-gtd.el][org-gtd]]. I haven't figured out my perfect workflow for tracking GTD with Org yet, but this looks like a very promising approach.

#+begin_src emacs-lisp :tangle packages.el
(package! org-gtd)
#+end_src
#+begin_src emacs-lisp
(use-package! org-gtd
  :after org
  :config
  ;; where org-gtd will put its files. This value is also the default one.
  (setq org-gtd-directory "~/GSync/gtd/")
  ;; package: https://github.com/Malabarba/org-agenda-property
  ;; this is so you can see who an item was delegated to in the agenda
  (setq org-agenda-property-list '("DELEGATED_TO"))
  ;; I think this makes the agenda easier to read
  (setq org-agenda-property-position 'next-line)
  ;; package: https://www.nongnu.org/org-edna-el/
  ;; org-edna is used to make sure that when a project task gets DONE,
  ;; the next TODO is automatically changed to NEXT.
  (setq org-edna-use-inheritance t)
  (org-edna-load)
  :bind
  (("C-c d c" . org-gtd-capture) ;; add item to inbox
   ("C-c d a" . org-agenda-list) ;; see what's on your plate today
   ("C-c d p" . org-gtd-process-inbox) ;; process entire inbox
   ("C-c d n" . org-gtd-show-all-next) ;; see all NEXT items
   ;; see projects that don't have a NEXT item
   ("C-c d s" . org-gtd-show-stuck-projects)
   ;; the keybinding to hit when you're done editing an item in the
   ;; processing phase
   ("C-c d f" . org-gtd-clarify-finalize)))
#+end_src

*** Capture templates

We define the corresponding Org-GTD capture templates.

#+begin_src emacs-lisp
(after! (org-gtd org-capture)
  (add-to-list 'org-capture-templates
               '("i" "GTD item"
                 entry
                 (file (lambda () (org-gtd--path org-gtd-inbox-file-basename)))
                 "* %?\n%U\n\n  %i"
                 :kill-buffer t))
  (add-to-list 'org-capture-templates
               '("l" "GTD item with link to where you are in emacs now"
                 entry
                 (file (lambda () (org-gtd--path org-gtd-inbox-file-basename)))
                 "* %?\n%U\n\n  %i\n  %a"
                 :kill-buffer t))
  (add-to-list 'org-capture-templates
               '("m" "GTD item with link to current Outlook mail message"
                 entry
                 (file (lambda () (org-gtd--path org-gtd-inbox-file-basename)))
                 "* %?\n%U\n\n  %i\n  %(org-mac-outlook-message-get-links)"
                 :kill-buffer t)))
#+end_src

I set up an advice before =org-capture= to make sure =org-gtd= and =org-capture= are loaded, which triggers the setup of the templates above.

#+begin_src emacs-lisp
(defadvice! +zz/load-org-gtd-before-capture (&optional goto keys)
    :before #'org-capture
    (require 'org-capture)
    (require 'org-gtd))
#+end_src
** Exporting a Curriculum Vitae

I use =ox-awesomecv= from [[https://titan-c.gitlab.io/org-cv/][Org-CV]], to export my [[https://github.com/zzamboni/vita/][Curriculum Vit\aelig]].

My =ox-awesomecv= package is [[https://gitlab.com/Titan-C/org-cv/-/merge_requests/3][not yet merged]] into the main Org-CV distribution, so I install from my branch for now.

#+begin_src emacs-lisp :tangle packages.el
(package! org-cv
  :recipe (:host gitlab :repo "zzamboni/org-cv" :branch "awesomecv"))
#+end_src
#+begin_src emacs-lisp
(use-package! ox-awesomecv
  :after org)
(use-package! ox-moderncv
  :after org)
#+end_src

** Code for org-mode macros

Here I define functions which get used in some of my org-mode macros

The first is a support function which gets used in some of the following, to
return a string (or an optional custom string) only if it is a non-zero,
non-whitespace string, and =nil= otherwise.

#+begin_src emacs-lisp
(defun zz/org-if-str (str &optional desc)
  (when (org-string-nw-p str)
    (or (org-string-nw-p desc) str)))
#+end_src

This function receives three arguments, and returns the org-mode code for a link
to the Hammerspoon API documentation for the =link= module, optionally to a
specific =function=. If =desc= is passed, it is used as the display text,
otherwise =section.function= is used.

#+begin_src emacs-lisp
(defun zz/org-macro-hsapi-code (module &optional func desc)
  (org-link-make-string
   (concat "https://www.hammerspoon.org/docs/"
           (concat module (zz/org-if-str func (concat "#" func))))
   (or (org-string-nw-p desc)
       (format "=%s="
               (concat module
                       (zz/org-if-str func (concat "." func)))))))
#+end_src

Split STR at spaces and wrap each element with the =~= char, separated by
=+=. Zero-width spaces are inserted around the plus signs so that they get
formatted correctly. Envisioned use is for formatting keybinding
descriptions. There are two versions of this function: "outer" wraps each
element in =~=, the "inner" wraps the whole sequence in them.

#+begin_src emacs-lisp
(defun zz/org-macro-keys-code-outer (str)
  (mapconcat (lambda (s)
               (concat "~" s "~"))
             (split-string str)
             (concat (string ?\u200B) "+" (string ?\u200B))))
(defun zz/org-macro-keys-code-inner (str)
  (concat "~" (mapconcat (lambda (s)
                           (concat s))
                         (split-string str)
                         (concat (string ?\u200B) "-" (string ?\u200B)))
          "~"))
(defun zz/org-macro-keys-code (str)
  (zz/org-macro-keys-code-inner str))
#+end_src

Links to a specific section/function of the Lua manual.

#+begin_src emacs-lisp
(defun zz/org-macro-luadoc-code (func &optional section desc)
  (org-link-make-string
   (concat "https://www.lua.org/manual/5.3/manual.html#"
           (zz/org-if-str func section))
   (zz/org-if-str func desc)))
#+end_src

#+begin_src emacs-lisp
(defun zz/org-macro-luafun-code (func &optional desc)
  (org-link-make-string
   (concat "https://www.lua.org/manual/5.3/manual.html#"
           (concat "pdf-" func))
   (zz/org-if-str (concat "=" func "()=") desc)))
#+end_src
** Reformatting an Org buffer

I picked up this little gem in the org mailing list. A function that reformats
the current buffer by regenerating the text from its internal parsed
representation. Quite amazing.

#+begin_src emacs-lisp
(defun zz/org-reformat-buffer ()
  (interactive)
  (when (y-or-n-p "Really format current buffer? ")
    (let ((document (org-element-interpret-data (org-element-parse-buffer))))
      (erase-buffer)
      (insert document)
      (goto-char (point-min)))))
#+end_src

** Avoiding non-Org mode files

[[https://github.com/tecosaur/org-pandoc-import][org-pandoc-import]] is a mode that automates conversions to/from Org mode as much as possible.

#+begin_src emacs-lisp :tangle packages.el
(package! org-pandoc-import
  :recipe (:host github
           :repo "tecosaur/org-pandoc-import"
           :files ("*.el" "filters" "preprocessors")))
#+end_src

#+begin_src emacs-lisp
(use-package org-pandoc-import)
#+end_src

** Reveal.js presentations

I use =org-re-reveal= to make presentations. The functions below help me improve my workflow by automatically exporting the slides whenever I save the file, refreshing the presentation in my browser, and moving it to the slide where the cursor was when I saved the file. This helps keeping a "live" rendering of the presentation next to my Emacs window.

The first function is a modified version of the =org-num--number-region= function of the =org-num= package, but modified to only return the numbering of the innermost headline in which the cursor is currently placed.

#+begin_src emacs-lisp
(defun zz/org-current-headline-number ()
  "Get the numbering of the innermost headline which contains the
cursor. Returns nil if the cursor is above the first level-1
headline, or at the very end of the file. Does not count
headlines tagged with :noexport:"
  (require 'org-num)
  (let ((org-num--numbering nil)
        (original-point (point)))
    (save-mark-and-excursion
      (let ((new nil))
        (org-map-entries
         (lambda ()
           (when (org-at-heading-p)
             (let* ((level (nth 1 (org-heading-components)))
                    (numbering (org-num--current-numbering level nil)))
               (let* ((current-subtree (save-excursion (org-element-at-point)))
                      (point-in-subtree
                       (<= (org-element-property :begin current-subtree)
                           original-point
                           (1- (org-element-property :end current-subtree)))))
                 ;; Get numbering to current headline if the cursor is in it.
                 (when point-in-subtree (push numbering
                                              new))))))
         "-noexport")
        ;; New contains all the trees that contain the cursor (i.e. the
        ;; innermost and all its parents), so we only return the innermost one.
        ;; We reverse its order to make it more readable.
        (reverse (car new))))))
#+end_src

The =zz/refresh-reveal-prez= function makes use of the above to perform the presentation export, refresh and update. You can use it by adding an after-save hook like this (add at the end of the file):

#+begin_example
,* Local variables :ARCHIVE:noexport:
# Local variables:
# eval: (add-hook! after-save :append :local (zz/refresh-reveal-prez))
# end:
#+end_example

*Note #1:* This is specific to my OS (macOS) and the browser I use (Brave). I will make it more generic in the future, but for now feel free to change it to your needs.

*Note #2:* the presentation must be already open in the browser, so you must run "Export to reveal.js -> To file and browse" (=C-c C-e v b=) once by hand.

#+begin_src emacs-lisp
(defun zz/refresh-reveal-prez ()
  ;; Export the file
  (org-re-reveal-export-to-html)
  (let* ((slide-list (zz/org-current-headline-number))
         (slide-str (string-join (mapcar #'number-to-string slide-list) "-"))
         ;; Determine the filename to use
         (file (concat (file-name-directory (buffer-file-name))
                       (org-export-output-file-name ".html" nil)))
         ;; Final URL including the slide number
         (uri (concat "file://" file "#/slide-" slide-str))
         ;; Get the document title
         (title (cadar (org-collect-keywords '("TITLE"))))
         ;; Command to reload the browser and move to the correct slide
         (cmd (concat
"osascript -e \"tell application \\\"Google Chrome\\\" to repeat with W in windows
set i to 0
repeat with T in (tabs in W)
set i to i + 1
if title of T is \\\"" title "\\\" then
  reload T
  delay 0.1
  set URL of T to \\\"" uri "\\\"
  set (active tab index of W) to i
end if
end repeat
end repeat\"")))
    ;; Short sleep seems necessary for the file changes to be noticed
    (sleep-for 0.2)
    (call-process-shell-command cmd)))
#+end_src

** Other exporters

[[https://github.com/stig/ox-jira.el][ox-jira]] to export in Jira markup format.

#+begin_src emacs-lisp :tangle packages.el
(package! ox-jira)
#+end_src

#+begin_src emacs-lisp
(use-package! ox-jira
  :after org)
#+end_src

[[https://github.com/ahungry/org-jira][org-jira]] for full Jira integration - manage issues from Org mode.

#+begin_src emacs-lisp :tangle packages.el
(package! org-jira)
#+end_src

#+begin_src emacs-lisp
(make-directory "~/.org-jira" 'ignore-if-exists)
(setq jiralib-url "https://jira.swisscom.com/")
#+end_src
** Programming Org

* Coding

** General

- =find-function-at-point= gets bound to =C-c l g p= (grouped together with other
  "go to" functions bound by Doom) and to =C-c C-f= (analog to the existing =C-c f=)
  for faster access.

  #+begin_src emacs-lisp
(after! prog-mode
  (map! :map prog-mode-map "C-h C-f" #'find-function-at-point)
  (map! :map prog-mode-map
        :localleader
        :desc "Find function at point"
        "g p" #'find-function-at-point))
  #+end_src

  #+begin_src emacs-lisp
;(after! prog-mode
;  (add-hook 'prog-mode-hook 'my-code-mode-hook))
  #+end_src
**** Electric utilities for ~prog-mode~​s.
#+begin_src emacs-lisp
(defun dwa/insert-pair(open close)
  (let* ((sel (dwa/selection))
         (selected (region-active-p)))
    (goto-char (cdr sel))
    (insert close)
    (set-marker-insertion-type (cdr sel) t)
    (goto-char (car sel))
    (insert open)
    (goto-char (cdr sel))
    (when selected (forward-char))))

(defun dwa/brace-pair()
  (interactive "*")
  (dwa/insert-pair "{ " " }"))


(defun dwa/smart-brace-pair()
  (interactive "*")
  (if (eq (char-before (car (dwa/selection))) ?$)
      (dwa/insert-pair "{" "}")
    (brace-pair)))

(defun dwa/dollar-brace-pair()
  (interactive "*")
  (dwa/insert-pair "${" "}"))

(defun dwa/mark-or-point ()
  "Return the mark if it is active, otherwise the point."
  (if
      (if (fboundp 'region-active-p) (region-active-p) mark-active)
      (mark)
    (point)))

(defun dwa/selection ()
  "Return a pair [start . finish) delimiting the current selection"
      (let ((start (make-marker))
            (finish (make-marker)))
        (set-marker start (min (dwa/mark-or-point) (point)))

        (set-marker finish (max (dwa/mark-or-point) (point)))
        (cons start finish)))

(defun dwa/replace-in-region (start finish key replacement)
  "In the range [START, FINISH), replace text matching KEY with REPLACEMENT"
  (goto-char start)
  (while (search-forward key finish t)
    (replace-match replacement)))

(defun dwa/activate-mark ()
  "Make the mark active if it is currently inactive"
  (set-mark (mark t)))

; return the first non-nil result of applying f to each element of seq
(defun dwa/first-non-nil (seq f)
  (and seq
       (or
        (apply f (list (car seq)))
        (dwa/first-non-nil (cdr seq) f)))
  )

(defun dwa/mode-read ()
  (let ((symb 'c++-mode)
	(predicate 'commandp)
	(enable-recursive-minibuffers t)
	val)
    (setq val (completing-read
	       (concat "Mode "
		       (if symb
			   (format " (default %s)" symb))
		       ": ")
	       obarray predicate t nil))
    (list (if (equal val "")
	      symb
	    (intern val)))))

(defun dwa/clone-region-set-mode (&optional mode)
  (interactive (dwa/mode-read))
  (let ((pt (point))(mk (dwa/mark-or-point)))
    (with-current-buffer (clone-indirect-buffer-other-window "*clone*" t)
    (narrow-to-region pt mk)
    (if mode
	(funcall mode)
      (lisp-mode)))))
#+end_src

** Literate Programming
 [[https://github.com/yilkalargaw/org-auto-tangle][org-auto-tangle]] makes literate programming tractable, by automatically running =org-babel-tangle= upon saving any org-mode buffer.

#+begin_src emacs-lisp :tangle packages.el
(package! org-auto-tangle)
#+end_src
#+begin_src emacs-lisp
(use-package! org-auto-tangle
  :defer t
  :hook (org-mode . org-auto-tangle-mode)
  :config
  (setq org-auto-tangle-default t))
#+end_src

** Elisp
Get in the habit of using sharp quote ([[https://endlessparentheses.com/get-in-the-habit-of-using-sharp-quote.html][article]]):

#+begin_src emacs-lisp
(defun endless/sharp ()
  "Insert #' unless in a string or comment."
  (interactive)
  (call-interactively #'self-insert-command)
  (let ((ppss (syntax-ppss)))
    (unless (or (elt ppss 3)
                (elt ppss 4)
                (eq (char-after) ?'))
      (insert "'"))))

(define-key emacs-lisp-mode-map "#" #'endless/sharp)
#+end_src

Some useful settings for LISP coding - =smartparens-strict-mode= to enforce
parenthesis to match. I map =M-(= to enclose the next expression as in =paredit=
using a custom function. Prefix argument can be used to indicate how many
expressions to enclose instead of just 1. E.g. =C-u 3 M-(= will enclose the next
3 sexps.

#+begin_src emacs-lisp
(defun zz/sp-enclose-next-sexp (num)
  (interactive "p")
  (insert-parentheses (or num 1)))

(after! smartparens
  (add-hook! (clojure-mode
              emacs-lisp-mode
              lisp-mode
              cider-repl-mode
              racket-mode
              racket-repl-mode) :append #'smartparens-strict-mode)
  (add-hook! smartparens-mode :append #'sp-use-paredit-bindings)
  (map! :map (smartparens-mode-map smartparens-strict-mode-map)
        "M-(" #'zz/sp-enclose-next-sexp))
#+end_src

Some other languages I use.

- [[https://graphviz.org/][Graphviz]] for graph generation.
  #+begin_src emacs-lisp :tangle packages.el
(package! graphviz-dot-mode)
  #+end_src
  #+begin_src emacs-lisp
(use-package! graphviz-dot-mode)
  #+end_src

- [[https://github.com/purcell/package-lint][package-lint]] for checking MELPA packages.
  #+begin_src emacs-lisp :tangle packages.el
(package! package-lint)
  #+end_src

* Other tools

- Trying out [[https://magit.vc/manual/magit/Repository-List.html][Magit's multi-repository abilities]]. This stays in sync with the git repo list used by my [[https://github.com/zzamboni/elvish-themes/blob/master/chain.org#bonus-displaying-the-status-of-several-git-repos-at-once][chain:summary-status]] Elvish shell function by reading the file every time =magit-list-repositories= is called, using =defadvice!=. I also customize the display to add the =Status= column.

  #+begin_src emacs-lisp
(after! magit
  (setq zz/repolist
        "~/.elvish/package-data/elvish-themes/chain-summary-repos.json")
  (defadvice! +zz/load-magit-repositories ()
    :before #'magit-list-repositories
    (setq magit-repository-directories
          (seq-map (lambda (e) (cons e 0)) (json-read-file zz/repolist))))
  (setq magit-repolist-columns
        '(("Name" 25 magit-repolist-column-ident nil)
          ("Status" 7 magit-repolist-column-flag nil)
          ("B<U" 3 magit-repolist-column-unpulled-from-upstream
           ((:right-align t)
            (:help-echo "Upstream changes not in branch")))
          ("B>U" 3 magit-repolist-column-unpushed-to-upstream
           ((:right-align t)
            (:help-echo "Local changes not in upstream")))
          ("Path" 99 magit-repolist-column-path nil))))
  #+end_src

- I prefer to use the GPG graphical PIN entry utility. This is achieved by
  setting =epg-pinentry-mode= (=epa-pinentry-mode= before Emacs 27) to =nil=
  instead of the default ='loopback=.

  #+begin_src emacs-lisp
(after! epa
  (set (if EMACS27+
           'epg-pinentry-mode
         'epa-pinentry-mode) ; DEPRECATED `epa-pinentry-mode'
       nil))
  #+end_src

- I find =iedit= absolutely indispensable when coding. In short: when you hit
  =Ctrl-;=, all occurrences of the symbol under the cursor (or the current
  selection) are highlighted, and any changes you make on one of them will be
  automatically applied to all others. It's great for renaming variables in
  code, but it needs to be used with care, as it has no idea of semantics, it's
  a plain string replacement, so it can inadvertently modify unintended parts of
  the code.

  #+begin_src emacs-lisp :tangle packages.el
(package! iedit)
  #+end_src
  #+begin_src emacs-lisp
(use-package! iedit
  :defer
  :config
  (set-face-background 'iedit-occurrence "Magenta")
  :bind
  ("C-;" . iedit-mode))
  #+end_src

- A useful macro (sometimes) for timing the execution of things. From [[https://stackoverflow.com/questions/23622296/emacs-timing-execution-of-function-calls-in-emacs-lisp][StackOverflow]].

  #+begin_src emacs-lisp
(defmacro zz/measure-time (&rest body)
  "Measure the time it takes to evaluate BODY."
  `(let ((time (current-time)))
     ,@body
     (float-time (time-since time))))
  #+end_src

- I'm still not fully convinced of running a terminal inside Emacs, but =vterm= is much nicer than any of the previous terminal emulators, so I'm giving it a try. I configure it so that it runs my [[https://elv.sh/][favorite shell]]. Vterm runs Elvish flawlessly!
  #+begin_src emacs-lisp
(setq vterm-shell "/usr/local/bin/fish")
  #+end_src

- Add "unfill" commands to parallel the "fill" ones, bind ~A-q~ to =unfill-paragraph= and rebind ~M-q~ to the =unfill-toggle= command, which fills/unfills paragraphs alternatively.

  #+begin_src emacs-lisp :tangle packages.el
(package! unfill)
  #+end_src
  #+begin_src emacs-lisp
(use-package! unfill
  :defer t
;  :bind
;  ("M-q" . unfill-toggle)
;  ("A-q" . unfill-paragraph))
)
  #+end_src

- The [[https://github.com/bastibe/annotate.el][annotate]] package is nice - allows adding annotations to files without modifying the file itself.

  #+begin_src emacs-lisp :tangle packages.el
(package! annotate)
  #+end_src
* Experiments

Make ox-md export src blocks with backticks and the language name.

#+begin_src emacs-lisp :tangle no
(defun org-md-example-block (example-block _contents info)
  "Transcode EXAMPLE-BLOCK element into Markdown format.
CONTENTS is nil.  INFO is a plist used as a communication
channel."
  (let ((lang (or (org-element-property :language example-block) "")))
    (format "```%s\n%s```\n"
            lang
            (org-remove-indentation
             (org-export-format-code-default example-block info)))))
#+end_src
* TODOs
** Get a modified indicator into the mode line
** Figure out how to dynamically rewrap paragraphs in Org files
Ideally we want to set a width limit.
** Figure out snippets for literate org.
** Resolve M-\ delete-horizontal-space binding 1P conflict.
** Figure out how to get ~`M-x o-b-tang'~ to complete to ~org-babel-tangle~
** Figure out how to autofill with the symbol under point
** Figure out how to get exactly matching ivy results to supercede other ones
